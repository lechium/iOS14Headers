/*
* This header is generated by classdump-dyld 1.0
* on Sunday, September 27, 2020 at 12:31:30 PM Mountain Standard Time
* Operating System: Version 14.0 (Build 18A373)
* Image Source: /System/Library/PrivateFrameworks/iWorkImport.framework/Frameworks/TSTables.framework/TSTables
* classdump-dyld is licensed under GPLv3, Copyright Â© 2013-2016 by Elias Limneos.
*/

#import <TSTables/TSTables-Structs.h>
#import <TSReading/TSPContainedObject.h>
#import <TSTables/TSTCompatibilityVersionProviding.h>

@class NSMutableIndexSet, TSTTableTileGroup, NSIndexSet;

@interface TSTTableTileStorage : TSPContainedObject <TSTCompatibilityVersionProviding> {

	NSMutableIndexSet* _tileIDSet;
	TSTTableTileGroup* _tileGroups[16];
	unsigned long long _archivingCompatibilityVersion;
	BOOL _upgradeRepairedTiles;
	BOOL _shouldUseWideRows;

}

@property (nonatomic,readonly) BOOL isEmbiggened; 
@property (nonatomic,readonly) unsigned long long nextTileID; 
@property (nonatomic,readonly) unsigned lastPopulatedRowIndex; 
@property (nonatomic,readonly) NSIndexSet * populatedTiles; 
@property (nonatomic,readonly) NSIndexSet * populatedRows; 
@property (nonatomic,readonly) BOOL needToUpgradeCellStorage; 
@property (nonatomic,readonly) BOOL upgradeRepairedTiles;                                     //@synthesize upgradeRepairedTiles=_upgradeRepairedTiles - In the implementation block
@property (assign,nonatomic) BOOL shouldUseWideRows;                                          //@synthesize shouldUseWideRows=_shouldUseWideRows - In the implementation block
@property (nonatomic,readonly) unsigned long long archivingCompatibilityVersion;              //@synthesize archivingCompatibilityVersion=_archivingCompatibilityVersion - In the implementation block
+(unsigned)tileSize;
+(id)_sharedQueue;
-(void)enumerateRowsWithBlock:(/*^block*/id)arg1 ;
-(void)reset;
-(id)initWithOwner:(id)arg1 ;
-(NSIndexSet *)populatedRows;
-(id)rowInfoAtIndex:(unsigned)arg1 ;
-(BOOL)needToUpgradeCellStorage;
-(void)setShouldUseWideRows:(BOOL)arg1 ;
-(BOOL)auditRowInfoCellCountsReturningResult:(id*)arg1 ;
-(BOOL)shouldUseWideRows;
-(unsigned long long)archivingCompatibilityVersion;
-(void)prepareToApplyConcurrentCellMap:(id)arg1 ;
-(void)removeRowsAtIndex:(unsigned)arg1 count:(unsigned)arg2 ;
-(void)removeColumnsAtIndex:(unsigned short)arg1 count:(unsigned)arg2 ;
-(void)moveRowIndexRange:(NSRange)arg1 toIndex:(unsigned)arg2 ;
-(void)moveColumnIndexRange:(NSRange)arg1 toIndex:(unsigned short)arg2 ;
-(void)swapRowAtIndex:(unsigned)arg1 withRowAtIndex:(unsigned)arg2 ;
-(void)insertColumnsAtIndex:(unsigned short)arg1 count:(unsigned)arg2 ;
-(id)_createTileWithID:(unsigned long long)arg1 ;
-(id)_groupForTileID:(unsigned long long)arg1 ;
-(void)pruneTilesForRows:(id)arg1 ;
-(void)_upgradeFromTileIDMap:(vector<std::__1::pair<unsigned int, unsigned long>, std::__1::allocator<std::__1::pair<unsigned int, unsigned long> > >*)arg1 referenceMap:(unordered_map<unsigned long, TSPLazyReference *, std::__1::hash<unsigned long>, std::__1::equal_to<unsigned long>, std::__1::allocator<std::__1::pair<const unsigned long, TSPLazyReference *> > >*)arg2 ;
-(id)_tileForID:(unsigned long long)arg1 createIfMissing:(BOOL)arg2 ;
-(BOOL)isEmbiggened;
-(void)_enumerateLoadedTiles:(/*^block*/id)arg1 ;
-(void)enumerateTilesConcurrentlyUsingBlock:(/*^block*/id)arg1 ;
-(void)_setTile:(id)arg1 forID:(unsigned long long)arg2 ;
-(void)_enumerateGroups:(/*^block*/id)arg1 ;
-(void)_removeTileForID:(unsigned long long)arg1 ;
-(unsigned)lastPopulatedRowIndex;
-(void)_shiftRowsDownAtIndex:(unsigned)arg1 count:(unsigned)arg2 ;
-(id)_yankRowRange:(NSRange)arg1 ;
-(void)_spliceRows:(id)arg1 atIndex:(unsigned)arg2 ;
-(void)_clearContentAtIndex:(unsigned)arg1 count:(unsigned)arg2 ;
-(void)_shiftRowsUpAtIndex:(unsigned)arg1 count:(unsigned)arg2 ;
-(void)_enumerateTiles:(/*^block*/id)arg1 ;
-(void)_insertRowsAtIndex:(unsigned)arg1 count:(unsigned)arg2 ;
-(void)_removeRowsAtIndex:(unsigned)arg1 count:(unsigned)arg2 ;
-(void)enumerateRowsInRange:(NSRange)arg1 withBlock:(/*^block*/id)arg2 ;
-(id)initWithStorageArchive:(const TileStorage*)arg1 treeArchive:(const TableRBTree*)arg2 nextTileID:(unsigned long long)arg3 unarchiver:(id)arg4 owner:(id)arg5 ;
-(void)saveToStorageArchive:(TileStorage*)arg1 treeArchive:(TableRBTree*)arg2 archiver:(id)arg3 ;
-(unsigned long long)nextTileID;
-(void)enumerateRowByRowInRange:(NSRange)arg1 withBlock:(/*^block*/id)arg2 ;
-(id)tileForWritingAtRowIndex:(unsigned)arg1 outTileRange:(NSRange*)arg2 ;
-(id)tileStartingAtOrBeforeRowIndex:(unsigned)arg1 outTileRange:(NSRange*)arg2 ;
-(id)tileStartingAtOrAfterRowIndex:(unsigned)arg1 outTileRange:(NSRange*)arg2 ;
-(void)insertRowsAtIndex:(unsigned)arg1 count:(unsigned)arg2 ;
-(id)columnCellCountsOfRowsInRange:(NSRange)arg1 ;
-(NSIndexSet *)populatedTiles;
-(void)pruneTileForRowIndex:(unsigned)arg1 ;
-(BOOL)auditTilesForRowOverlapAndExtensionPastTableBounds:(TSUCellCoord)arg1 withDataStore:(id)arg2 result:(id*)arg3 ;
-(void)widenTilesForUpgrade;
-(multimap<TSUCellCoord, std::__1::tuple<unsigned int, unsigned long, TSTCellStorage *>, std::__1::less<TSUCellCoord>, std::__1::allocator<std::__1::pair<const TSUCellCoord, std::__1::tuple<unsigned int, unsigned long, TSTCellStorage *> > > >*)makeStorageMap;
-(BOOL)upgradeRepairedTiles;
@end

